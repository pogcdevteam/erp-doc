{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ERP Project Documentation Welcome to ERP Project documentation.","title":"Home"},{"location":"#erp-project-documentation","text":"Welcome to ERP Project documentation.","title":"ERP Project Documentation"},{"location":"apps/hrms/attendance/","text":"Loading ...","title":"Attendance"},{"location":"apps/hrms/structure/","text":"Folder Structure Folder structure for hrms app is as folloiwng: hrms \u251c\u2500\u2500 admins \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 models \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 __pycache__ \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 hrms \u2502 \u251c\u2500\u2500 attendance \u2502 \u251c\u2500\u2500 base \u2502 \u2502 \u2514\u2500\u2500 profile \u2502 \u2514\u2500\u2500 minimals \u2514\u2500\u2500 views \u2514\u2500\u2500 __pycache__","title":"Folder Structure"},{"location":"apps/hrms/structure/#folder-structure","text":"Folder structure for hrms app is as folloiwng: hrms \u251c\u2500\u2500 admins \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 models \u2502 \u2514\u2500\u2500 __pycache__ \u251c\u2500\u2500 __pycache__ \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 hrms \u2502 \u251c\u2500\u2500 attendance \u2502 \u251c\u2500\u2500 base \u2502 \u2502 \u2514\u2500\u2500 profile \u2502 \u2514\u2500\u2500 minimals \u2514\u2500\u2500 views \u2514\u2500\u2500 __pycache__","title":"Folder Structure"},{"location":"backend/backend/","text":"Loading ...","title":"Backend"},{"location":"frontend/datatable/","text":"Datatable component has been used in the project in multiple places where we need to render a nice and responsive table for users with search and export options. You can visit website for more information about use cases: Datatable Implementation In order to render datatable for html tables you need to set id attribute of that table tag to \"dataTable\". <table id=\"dataTable\"> </table> Export Buttons Export and print options enabled for end user. User can export data to excel and csv files and also is able to print the whole table at once. Static Files Databale static files are stored in datatable directory.","title":"Datatable"},{"location":"frontend/datatable/#implementation","text":"In order to render datatable for html tables you need to set id attribute of that table tag to \"dataTable\". <table id=\"dataTable\"> </table>","title":"Implementation"},{"location":"frontend/datatable/#export-buttons","text":"Export and print options enabled for end user. User can export data to excel and csv files and also is able to print the whole table at once.","title":"Export Buttons"},{"location":"frontend/datatable/#static-files","text":"Databale static files are stored in datatable directory.","title":"Static Files"},{"location":"frontend/modal/","text":"Forms Soemtimes we would like show forms as modals, no matter if it is a create new or edit form. In all that cases we expect the following behvaiour: A modal is shown when user click on Create New button. If user put invalid data and the form gives errors so we expect the modal to stay in place and not to close. If user puts valid data with a successfull response, the modal disapperas and the list of items is updated. Consider the following example: We have the following index.html file : <button hx-get=\"/list-of-items\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click\"> List of Items </button> <div id=\"content\"> <div> When user click on the button the content of request will be swapped in inner html of div with id attribute of content . Consider the response as following: <button hx-get=\"/create-new\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click\"> Create New </button> <div> {% for object in object_list %} {{object.name}} {%endfor%} </div> If the user click on Create New button we would like to a modal form to show up. So we need to modify the above code as below: <button hx-get=\"/create-new\" hx-swap=\"innerHTML\" hx-target=\"#dialog\" hx-trigger=\"click\" data-bs-toggle=\"modal\" data-bs-target=\"#staticBackdrop\"> Create New </button> <div> {% for object in object_list %} {{object.name}} {%endfor%} </div> When user click on Create New button the request is sent to server and the folloiwng template that provide a modal form woul dbe rendered. {% load django_bootstrap5 %} <form hx-post=\"{{ request.path }}\" class=\"modal-content\" enctype=\"multipart/form-data\"> {% csrf_token %} <div class=\"modal-header\"> <div class=\"modal-title\">Modal Title</div> {% include 'minimal/modal-close-button.html' %} </div> <div class=\"modal-body\"> </div> <div class=\"modal-footer\"> {% include 'minimal/save-button.html' %} </div> </form> Now we need to customize our CreateView and make sure the response with statuc code of 204 is returened when data is saved with no error. In order to let htmx know when are going to update the list of items we need to define a custom trigger and use that when we would like to update the list of data. As you see we have defined custom trigger called exampleChanged class ExampleCreateView(CreateView): def form_valid(self, form): object = form.save(commit = False) object.save() return HttpResponse(status=204, headers={'HX-Trigger': 'exampleChanged'}) Now we need to add the custom trigger to the the button so our first example will change as following: <button hx-get=\"/list-of-items\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click, exampleChanged from:body\"> List of Items </button> <div id=\"content\"> <div>","title":"Modal"},{"location":"frontend/modal/#forms","text":"Soemtimes we would like show forms as modals, no matter if it is a create new or edit form. In all that cases we expect the following behvaiour: A modal is shown when user click on Create New button. If user put invalid data and the form gives errors so we expect the modal to stay in place and not to close. If user puts valid data with a successfull response, the modal disapperas and the list of items is updated. Consider the following example: We have the following index.html file : <button hx-get=\"/list-of-items\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click\"> List of Items </button> <div id=\"content\"> <div> When user click on the button the content of request will be swapped in inner html of div with id attribute of content . Consider the response as following: <button hx-get=\"/create-new\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click\"> Create New </button> <div> {% for object in object_list %} {{object.name}} {%endfor%} </div> If the user click on Create New button we would like to a modal form to show up. So we need to modify the above code as below: <button hx-get=\"/create-new\" hx-swap=\"innerHTML\" hx-target=\"#dialog\" hx-trigger=\"click\" data-bs-toggle=\"modal\" data-bs-target=\"#staticBackdrop\"> Create New </button> <div> {% for object in object_list %} {{object.name}} {%endfor%} </div> When user click on Create New button the request is sent to server and the folloiwng template that provide a modal form woul dbe rendered. {% load django_bootstrap5 %} <form hx-post=\"{{ request.path }}\" class=\"modal-content\" enctype=\"multipart/form-data\"> {% csrf_token %} <div class=\"modal-header\"> <div class=\"modal-title\">Modal Title</div> {% include 'minimal/modal-close-button.html' %} </div> <div class=\"modal-body\"> </div> <div class=\"modal-footer\"> {% include 'minimal/save-button.html' %} </div> </form> Now we need to customize our CreateView and make sure the response with statuc code of 204 is returened when data is saved with no error. In order to let htmx know when are going to update the list of items we need to define a custom trigger and use that when we would like to update the list of data. As you see we have defined custom trigger called exampleChanged class ExampleCreateView(CreateView): def form_valid(self, form): object = form.save(commit = False) object.save() return HttpResponse(status=204, headers={'HX-Trigger': 'exampleChanged'}) Now we need to add the custom trigger to the the button so our first example will change as following: <button hx-get=\"/list-of-items\" hx-swap=\"innerHTML\" hx-target=\"#content\" hx-trigger=\"click, exampleChanged from:body\"> List of Items </button> <div id=\"content\"> <div>","title":"Forms"},{"location":"frontend/themes/","text":"Bootstrap Theme and styling is based on bootstrap v5.*. Multiple themes provided by Bootswatch used in the poroject. Dark Theme For almost all Bootswatch themes, paired light and dark theme has been provided. Users can switch between light and dark mode in setting left side offcanvas. Note For the time being the default theme is not stored or retrived from backend. All theme settings is stored in local storage on the user browser.","title":"Themes"},{"location":"frontend/themes/#bootstrap","text":"Theme and styling is based on bootstrap v5.*. Multiple themes provided by Bootswatch used in the poroject.","title":"Bootstrap"},{"location":"frontend/themes/#dark-theme","text":"For almost all Bootswatch themes, paired light and dark theme has been provided. Users can switch between light and dark mode in setting left side offcanvas. Note For the time being the default theme is not stored or retrived from backend. All theme settings is stored in local storage on the user browser.","title":"Dark Theme"},{"location":"git/branch/","text":"Branching Quick Legend Instance Branch Description, Instructions, Notes Stable stable Accepts merges from Working and Hotfixes Working main Accepts merges from Features/Issues and Hotfixes Features/Issues topic-* Always branch off HEAD of Working Hotfix hotfix-* Always branch off Stable Main Branches The main repository will always hold two evergreen branches: main stable The main branch should be considered origin/main and will be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. As a developer, you will be branching and merging from main . Consider origin/stable to always represent the latest code deployed to production. During day to day development, the stable branch will not be interacted with. When the source code in the main branch is stable and has been deployed, all of the changes will be merged into stable and tagged with a release number. How this is done in detail will be discussed later. Supporting Branches Supporting branches are used to aid parallel development between team members, ease tracking of features, and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually. The different types of branches we may use are: Feature branches Bug/Fix branches Hotfix branches Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets. Each branch and its usage is explained below. Feature Branches Feature branches are used when developing a new feature or enhancement which has the potential of a development lifespan longer than a single deployment. When starting development, the deployment in which this feature will be released may not be known. No matter when the feature branch will be finished, it will always be merged back into the main branch. During the lifespan of the feature development, the lead should watch the main branch (network tool or branch tool in GitHub) to see if there have been commits since the feature was branched. Any and all changes to main should be merged into the feature before merging back to main ; this can be done at various times during the project or at the end, but time to handle merge conflicts should be accounted for. <tbd number> represents the project to which Project Management will be tracked. Must branch from: main Must merge back into: main Branch naming convention: feature-<tbd number> Working with a feature branch If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A feature branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b feature-id main // creates a local branch for the new feature $ git push origin feature-id // makes the new feature remotely available Periodically, changes made to main (if any) should be merged back into your feature branch. $ git merge main // merges changes from main into feature branch When development on the feature is complete, the lead (or engineer in charge) should merge changes into main and then make sure the remote branch is deleted. $ git checkout main // change to the main branch $ git merge --no-ff feature-id // makes sure to create a commit object during merge $ git push origin main // push merge changes $ git push origin :feature-id // deletes the remote branch Bug Branches Bug branches differ from feature branches only semantically. Bug branches will be created when there is a bug on the live site that should be fixed and merged into the next deployment. For that reason, a bug branch typically will not last longer than one deployment cycle. Additionally, bug branches are used to explicitly track the difference between bug development and feature development. No matter when the bug branch will be finished, it will always be merged back into main . Although likelihood will be less, during the lifespan of the bug development, the lead should watch the main branch (network tool or branch tool in GitHub) to see if there have been commits since the bug was branched. Any and all changes to main should be merged into the bug before merging back to main ; this can be done at various times during the project or at the end, but time to handle merge conflicts should be accounted for. <tbd number> represents the Basecamp project to which Project Management will be tracked. Must branch from: main Must merge back into: main Branch naming convention: bug-<tbd number> Working with a bug branch If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A bug branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b bug-id main // creates a local branch for the new bug $ git push origin bug-id // makes the new bug remotely available Periodically, changes made to main (if any) should be merged back into your bug branch. $ git merge main // merges changes from main into bug branch When development on the bug is complete, [the Lead] should merge changes into main and then make sure the remote branch is deleted. $ git checkout main // change to the main branch $ git merge --no-ff bug-id // makes sure to create a commit object during merge $ git push origin main // push merge changes $ git push origin :bug-id // deletes the remote branch Hotfix Branches A hotfix branch comes from the need to act immediately upon an undesired state of a live production version. Additionally, because of the urgency, a hotfix is not required to be be pushed during a scheduled deployment. Due to these requirements, a hotfix branch is always branched from a tagged stable branch. This is done for two reasons: Development on the main branch can continue while the hotfix is being addressed. A tagged stable branch still represents what is in production. At the point in time where a hotfix is needed, there could have been multiple commits to main which would then no longer represent production. <tbd number> represents the Basecamp project to which Project Management will be tracked. Must branch from: tagged stable Must merge back into: main and stable Branch naming convention: hotfix-<tbd number> Working with a hotfix branch If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A hotfix branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b hotfix-id stable // creates a local branch for the new hotfix $ git push origin hotfix-id // makes the new hotfix remotely available When development on the hotfix is complete, [the Lead] should merge changes into stable and then update the tag. $ git checkout stable // change to the stable branch $ git merge --no-ff hotfix-id // forces creation of commit object during merge $ git tag -a <tag> // tags the fix $ git push origin stable --tags // push tag changes Merge changes into main so not to lose the hotfix and then delete the remote hotfix branch. $ git checkout main // change to the main branch $ git merge --no-ff hotfix-id // forces creation of commit object during merge $ git push origin main // push merge changes $ git push origin :hotfix-id // deletes the remote branch","title":"Branch Naming Convention"},{"location":"git/branch/#branching","text":"","title":"Branching"},{"location":"git/branch/#quick-legend","text":"Instance Branch Description, Instructions, Notes Stable stable Accepts merges from Working and Hotfixes Working main Accepts merges from Features/Issues and Hotfixes Features/Issues topic-* Always branch off HEAD of Working Hotfix hotfix-* Always branch off Stable","title":"Quick Legend"},{"location":"git/branch/#main-branches","text":"The main repository will always hold two evergreen branches: main stable The main branch should be considered origin/main and will be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. As a developer, you will be branching and merging from main . Consider origin/stable to always represent the latest code deployed to production. During day to day development, the stable branch will not be interacted with. When the source code in the main branch is stable and has been deployed, all of the changes will be merged into stable and tagged with a release number. How this is done in detail will be discussed later.","title":"Main Branches"},{"location":"git/branch/#supporting-branches","text":"Supporting branches are used to aid parallel development between team members, ease tracking of features, and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually. The different types of branches we may use are: Feature branches Bug/Fix branches Hotfix branches Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets. Each branch and its usage is explained below.","title":"Supporting Branches"},{"location":"git/branch/#feature-branches","text":"Feature branches are used when developing a new feature or enhancement which has the potential of a development lifespan longer than a single deployment. When starting development, the deployment in which this feature will be released may not be known. No matter when the feature branch will be finished, it will always be merged back into the main branch. During the lifespan of the feature development, the lead should watch the main branch (network tool or branch tool in GitHub) to see if there have been commits since the feature was branched. Any and all changes to main should be merged into the feature before merging back to main ; this can be done at various times during the project or at the end, but time to handle merge conflicts should be accounted for. <tbd number> represents the project to which Project Management will be tracked. Must branch from: main Must merge back into: main Branch naming convention: feature-<tbd number>","title":"Feature Branches"},{"location":"git/branch/#working-with-a-feature-branch","text":"If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A feature branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b feature-id main // creates a local branch for the new feature $ git push origin feature-id // makes the new feature remotely available Periodically, changes made to main (if any) should be merged back into your feature branch. $ git merge main // merges changes from main into feature branch When development on the feature is complete, the lead (or engineer in charge) should merge changes into main and then make sure the remote branch is deleted. $ git checkout main // change to the main branch $ git merge --no-ff feature-id // makes sure to create a commit object during merge $ git push origin main // push merge changes $ git push origin :feature-id // deletes the remote branch","title":"Working with a feature branch"},{"location":"git/branch/#bug-branches","text":"Bug branches differ from feature branches only semantically. Bug branches will be created when there is a bug on the live site that should be fixed and merged into the next deployment. For that reason, a bug branch typically will not last longer than one deployment cycle. Additionally, bug branches are used to explicitly track the difference between bug development and feature development. No matter when the bug branch will be finished, it will always be merged back into main . Although likelihood will be less, during the lifespan of the bug development, the lead should watch the main branch (network tool or branch tool in GitHub) to see if there have been commits since the bug was branched. Any and all changes to main should be merged into the bug before merging back to main ; this can be done at various times during the project or at the end, but time to handle merge conflicts should be accounted for. <tbd number> represents the Basecamp project to which Project Management will be tracked. Must branch from: main Must merge back into: main Branch naming convention: bug-<tbd number>","title":"Bug Branches"},{"location":"git/branch/#working-with-a-bug-branch","text":"If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A bug branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b bug-id main // creates a local branch for the new bug $ git push origin bug-id // makes the new bug remotely available Periodically, changes made to main (if any) should be merged back into your bug branch. $ git merge main // merges changes from main into bug branch When development on the bug is complete, [the Lead] should merge changes into main and then make sure the remote branch is deleted. $ git checkout main // change to the main branch $ git merge --no-ff bug-id // makes sure to create a commit object during merge $ git push origin main // push merge changes $ git push origin :bug-id // deletes the remote branch","title":"Working with a bug branch"},{"location":"git/branch/#hotfix-branches","text":"A hotfix branch comes from the need to act immediately upon an undesired state of a live production version. Additionally, because of the urgency, a hotfix is not required to be be pushed during a scheduled deployment. Due to these requirements, a hotfix branch is always branched from a tagged stable branch. This is done for two reasons: Development on the main branch can continue while the hotfix is being addressed. A tagged stable branch still represents what is in production. At the point in time where a hotfix is needed, there could have been multiple commits to main which would then no longer represent production. <tbd number> represents the Basecamp project to which Project Management will be tracked. Must branch from: tagged stable Must merge back into: main and stable Branch naming convention: hotfix-<tbd number>","title":"Hotfix Branches"},{"location":"git/branch/#working-with-a-hotfix-branch","text":"If the branch does not exist yet (check with the Lead), create the branch locally and then push to GitHub. A hotfix branch should always be 'publicly' available. That is, development should never exist in just one developer's local branch. $ git checkout -b hotfix-id stable // creates a local branch for the new hotfix $ git push origin hotfix-id // makes the new hotfix remotely available When development on the hotfix is complete, [the Lead] should merge changes into stable and then update the tag. $ git checkout stable // change to the stable branch $ git merge --no-ff hotfix-id // forces creation of commit object during merge $ git tag -a <tag> // tags the fix $ git push origin stable --tags // push tag changes Merge changes into main so not to lose the hotfix and then delete the remote hotfix branch. $ git checkout main // change to the main branch $ git merge --no-ff hotfix-id // forces creation of commit object during merge $ git push origin main // push merge changes $ git push origin :hotfix-id // deletes the remote branch","title":"Working with a hotfix branch"}]}